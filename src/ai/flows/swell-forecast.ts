// This file is generated by EVERYBodYsurf

/**
 * @fileOverview Provides a GenAI-powered surf report and/or forecast
 * with full detail for pros, and user-friendly summarries for newb    // Step 2: Get weather and marine data using One Call API 3.0
    const ONECALL_BASE_URL = 'https://api.openweathermap.org/data/3.0/onecall';
    
    let weatherUrl = `${ONECALL_BASE_URL}?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric&exclude=minutely,alerts`;
    
    // Handle date parameters - One Call API provides current + 7 days forecast
    if (input.date || (input.startDate && input.endDate)) {
      console.log('Note: One Call API provides current + 7-day forecast. Date filtering will be applied to results.');
    }

    console.log('Fetching weather and marine data from One Call API URL:', weatherUrl);
    const response = await fetch(weatherUrl);

    if (!response.ok) {
      throw new Error(`One Call API error! status: ${response.status}`);
    }

    const data = await response.json();ellForecast - A function that generates a swell forecast summary.
 * - Swel prompt: `You are an expert surf forecaster, providing concise summaries for surfers who want to know where and when to surf. Based on the following weather and marine conditions for {{{surfSpot}}} on {{{date}}}:

Weather Conditions:
- Temperature: {{{avgtemp_c}}}°C ({{{avgtemp_f}}}°F)
- Max Wind Speed: {{{maxwind_mph}}} mph
- Wind Direction: {{{wind_dir}}}
- Humidity: {{{avghumidity}}}%
- Visibility: {{{avgvis_km}}} km
- UV Index: {{{uv}}}
- Precipitation: {{{totalprecip_mm}}} mm

Marine Conditions:
{{#if swell_ht_mt}}
- Swell Height: {{{swell_ht_ft}}} ft ({{{swell_ht_mt}}} m)
- Swell Period: {{{swell_period_secs}}} seconds
- Swell Direction: {{{swell_dir_16_point}}} ({{{swell_dir}}}°)
{{/if}}
{{#if water_temp_c}}
- Water Temperature: {{{water_temp_c}}}°C ({{{water_temp_f}}}°F)
{{/if}}
{{#if sig_ht_mt}}
- Significant Wave Height: {{{sig_ht_mt}}} m
{{/if}}

Astronomical Data:
- Sunrise: {{{sunrise}}}
- Sunset: {{{sunset}}}
{{#if moonrise}}
- Moonrise: {{{moonrise}}}
- Moonset: {{{moonset}}}
- Moon Phase: {{{moon_phase}}}
{{/if}}

{{#if tide_time}}
Tide Information:
- Tide Time: {{{tide_time}}}
- Tide Type: {{{tide_type}}}
{{else}}
Note: Tide information not available from current data source.
{{/if}}

Based on these conditions, provide a comprehensive surf forecast summary and advise the user whether, when and where to go surfing. Consider wave quality, wind conditions, water temperature, and timing. Cite general surfing knowledge and weather patterns in your response.

Format your response as a JSON object with two keys: "forecastSummary" and "detailedData". The value of "forecastSummary" should be your summary and advice. The value of "detailedData" should be the original input data you received, in JSON format.`, - The input type for the getSwellForecast function.
 * - SwellForecastOutput - The return type for the getSwellForecast function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'zod';

const SwellForecastInputSchema = z.object({ // This is the schema for the input received by the `getSwellForecast` function
 surfSpot: z.string().describe('The name of the surf spot to get the swell forecast for.'),//
 date: z.string().optional().describe('The date of the forecast (for single-day forecast).'),
 startDate: z.string().optional().describe('Start date of the forecast range (for multi-day forecast).'),
 endDate: z.string().optional().describe('End date of the forecast range (for multi-day forecast).'),
});

export type SwellForecastInput = z.infer<typeof SwellForecastInputSchema>;

const SwellForecastOutputSchema = z.object({
  forecastSummary: z.string().describe('A concise, user-friendly summary of the surf conditions for the specified surf spot, including wave height, period, wind, and tide information. It should also advise the user whether, when and where to go surfing, citing to expert blogs, forecasts or historical performance in its answer.'),
  detailedData: z.object({ // This is the schema for the detailed data that the AI model will receive
    surfSpot: z.string().describe('The name of the surf spot to get the swell forecast for.'), //
    date: z.string().describe('Date of the forecast.'),
    date_epoch: z.number().describe('Forecast date as unix time.'),
    maxtemp_c: z.number().describe('Maximum temperature in Celsius.'),
    maxtemp_f: z.number().describe('Maximum temperature in Fahrenheit.'),
    mintemp_c: z.number().describe('Minimum temperature in Celsius.'),
    mintemp_f: z.number().describe('Minimum temperature in Fahrenheit.'),
    avgtemp_c: z.number().describe('Average temperature in Celsius.'),
    avgtemp_f: z.number().describe('Average temperature in Fahrenheit.'),
    maxwind_mph: z.number().describe('Maximum wind speed in miles per hour.'),
    maxwind_kph: z.number().describe('Maximum wind speed in kilometer per hour.'),
    totalprecip_mm: z.number().describe('Total precipitation in millimeters.'),
    totalprecip_in: z.number().describe('Total precipitation in inches.'),
    avgvis_km: z.number().describe('Average visibility in kilometers.'),
    avgvis_miles: z.number().describe('Average visibility in miles.'),
    avghumidity: z.number().describe('Average humidity.'),
    condition_icon: z.string().describe('Weather condition icon.'), // Day condition icon
    uv: z.number().describe('UV index.'),
    sunrise: z.string().describe('Sunrise time.'),
    sunset: z.string().describe('Sunset time.'),
    moonrise: z.string().describe('Moonrise time.'),
    moonset: z.string().describe('Moonset time.'),
    moon_phase: z.string().describe('Moon phase.'),
    moon_illumination: z.number().describe('Moon illumination percentage.'),
    is_moon_up: z.number().describe('Whether the moon is currently up (1 = Yes, 0 = No).'),
    is_sun_up: z.number().describe('Whether the sun is currently up (1 = Yes, 0 = No).'),
    tide_time: z.string().nullable().describe('Time of the tide.'),
    tide_height_mt: z.number().nullable().describe('Height of the tide in meters.'),
    tide_type: z.string().nullable().describe('Type of the tide (e.g., HIGH, LOW).'),
    hourlyForecast: z.array(z.object({
      time_epoch: z.number().describe('Time as epoch.'),
      time: z.string().describe('Date and time.'),
      temp_c: z.number().describe('Temperature in celsius.'),
      temp_f: z.number().describe('Temperature in fahrenheit.'),
      condition_icon: z.string().describe('Weather condition icon.'), // Hourly condition icon
      wind_mph: z.number().describe('Maximum wind speed in miles per hour.'),
      wind_kph: z.number().describe('Maximum wind speed in kilometer per hour.'),
      wind_degree: z.number().describe('Wind direction in degrees.'),
      wind_dir: z.string().describe('Wind direction as 16 point compass.'),
      pressure_mb: z.number().describe('Pressure in millibars.'),
      pressure_in: z.number().describe('Pressure in inches.'),
      precip_mm: z.number().describe('Precipitation amount in millimeters.'),
      precip_in: z.number().describe('Precipitation amount in inches.'),
      humidity: z.number().describe('Humidity as percentage.'),
      cloud: z.number().describe('Cloud cover as percentage.'),
      feelslike_c: z.number().describe('Feels like temperature as celcius.'),
      feelslike_f: z.number().describe('Feels like temperature as fahrenheit.'),
      windchill_c: z.number().describe('Windchill temperature in celcius.'),
      windchill_f: z.number().describe('Windchill temperature in fahrenheit.'),
      heatindex_c: z.number().describe('Heat index in celcius.'),
      heatindex_f: z.number().describe('Heat index in fahrenheit.'),
      dewpoint_c: z.number().describe('Dew point in celcius.'),
      dewpoint_f: z.number().describe('Dew point in fahrenheit.'),
      is_day: z.number().describe('Whether to show day condition icon or night icon (1 = Yes, 0 = No).'),
      vis_km: z.number().describe('Visibility in kilometer.'),
      vis_miles: z.number().describe('Visibility in miles.'),
      gust_mph: z.number().describe('Wind gust in miles per hour.'),
      gust_kph: z.number().describe('Wind gust in kilometer per hour.'),
      sig_ht_mt: z.number().describe('Significant wave height in metres.'),
      swell_ht_mt: z.number().describe('Swell wave height in metres.'),
      swell_ht_ft: z.number().describe('Swell wave height in feet.'),
      uv: z.number().describe('UV index.'),
      swell_dir: z.number().describe('Swell direction in degrees.'),
      swell_dir_16_point: z.string().describe('Swell direction in 16 point compass.'),
      swell_period_secs: z.number().describe('Swell period in seconds.'),
      water_temp_c: z.number().describe('Water temperature in Celcius.'),
      water_temp_f: z.number().describe('Water temperature in Fahrenheit.'),
    })).describe('Hourly weather and swell data.'),
  }).describe('Detailed extracted weather and swell data.'),
});
export type SwellForecastOutput = z.infer<typeof SwellForecastOutputSchema>;

// Helper functions for OpenWeatherMap API data conversion
function getWindDirection(degrees: number): string {
  const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
  return directions[Math.round(degrees / 22.5) % 16];
}

function calculateDewPoint(tempC: number, humidity: number): number {
  // Magnus formula for dew point calculation
  const a = 17.27;
  const b = 237.7;
  const alpha = ((a * tempC) / (b + tempC)) + Math.log(humidity / 100);
  return (b * alpha) / (a - alpha);
}

export async function getSwellForecast(input: SwellForecastInput): Promise<SwellForecastOutput> {
  console.log('getSwellForecast function called with input:', input);
  const API_KEY = process.env.OPENWEATHER_API_KEY;
  const GEOCODING_URL = 'https://api.openweathermap.org/geo/1.0/direct';
  
  if (!API_KEY) {
    throw new Error('OpenWeatherMap API key is not configured. Please set OPENWEATHER_API_KEY environment variable.');
  }

  try {
    // Step 1: Get coordinates for the surf spot using geocoding
    console.log('Geocoding surf spot:', input.surfSpot);
    const geocodingUrl = `${GEOCODING_URL}?q=${encodeURIComponent(input.surfSpot)}&limit=1&appid=${API_KEY}`;
    console.log('Geocoding URL:', geocodingUrl);
    
    const geocodingResponse = await fetch(geocodingUrl);
    if (!geocodingResponse.ok) {
      throw new Error(`Geocoding API error! status: ${geocodingResponse.status}`);
    }
    
    const geocodingData = await geocodingResponse.json();
    console.log('Geocoding response:', geocodingData);
    
    if (!geocodingData || geocodingData.length === 0) {
      throw new Error(`Could not find coordinates for surf spot: ${input.surfSpot}`);
    }
    
    const { lat, lon } = geocodingData[0];
    console.log('Coordinates found:', { lat, lon });

    // Step 2: Get weather data using forecast API (free tier compatible)
    // Note: One Call API 3.0 requires a paid subscription
    const FORECAST_BASE_URL = 'https://api.openweathermap.org/data/2.5/forecast';
    
    let weatherUrl = `${FORECAST_BASE_URL}?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric`;
    
    // Handle date parameters - forecast API provides 5-day forecast
    if (input.date || (input.startDate && input.endDate)) {
      console.log('Note: OpenWeatherMap free tier provides 5-day forecast. Date filtering will be applied to results.');
    }

    console.log('Fetching weather data from URL:', weatherUrl);
    const response = await fetch(weatherUrl);

    if (!response.ok) {
      throw new Error(`Weather API error! status: ${response.status}`);
    }

    const data = await response.json();

    console.log('OpenWeatherMap Response Data:', data);

    // Helper function to convert Celsius to Fahrenheit
    const celsiusToFahrenheit = (celsius: number) => (celsius * 9/5) + 32;
    // Helper function to convert m/s to mph
    const msToMph = (ms: number) => ms * 2.237;
    // Helper function to convert m/s to kph
    const msToKph = (ms: number) => ms * 3.6;
    // Helper function to convert meters to miles
    const metersToMiles = (meters: number) => meters * 0.000621371;

    // Get current date for fallback
    const currentDate = new Date().toISOString().split('T')[0];
    const currentEpoch = Math.floor(Date.now() / 1000);

    // Extract forecast data from forecast API structure
    const forecastList = data.list || [];
    const firstForecast = forecastList.length > 0 ? forecastList[0] : null;
    
    // Calculate daily aggregates from 3-hour forecasts
    const dailyTemps = forecastList.map((item: any) => item.main.temp);
    const dailyWinds = forecastList.map((item: any) => item.wind.speed);
    const dailyPrecip = forecastList.map((item: any) => item.rain?.['3h'] || 0);
    const dailyHumidity = forecastList.map((item: any) => item.main.humidity);
    
    // Extract relevant data adapted for forecast API structure
    const extractedData = {
      surfSpot: input.surfSpot,
      date: input.date || currentDate,
      date_epoch: firstForecast?.dt || currentEpoch,
      maxtemp_c: Math.max(...dailyTemps.slice(0, 8)) || (firstForecast?.main?.temp || 0),
      maxtemp_f: celsiusToFahrenheit(Math.max(...dailyTemps.slice(0, 8)) || (firstForecast?.main?.temp || 0)),
      mintemp_c: Math.min(...dailyTemps.slice(0, 8)) || (firstForecast?.main?.temp || 0),
      mintemp_f: celsiusToFahrenheit(Math.min(...dailyTemps.slice(0, 8)) || (firstForecast?.main?.temp || 0)),
      avgtemp_c: dailyTemps.slice(0, 8).reduce((a: number, b: number) => a + b, 0) / Math.min(dailyTemps.length, 8) || (firstForecast?.main?.temp || 0),
      avgtemp_f: celsiusToFahrenheit(dailyTemps.slice(0, 8).reduce((a: number, b: number) => a + b, 0) / Math.min(dailyTemps.length, 8) || (firstForecast?.main?.temp || 0)),
      maxwind_mph: msToMph(Math.max(...dailyWinds.slice(0, 8)) || (firstForecast?.wind?.speed || 0)),
      maxwind_kph: msToKph(Math.max(...dailyWinds.slice(0, 8)) || (firstForecast?.wind?.speed || 0)),
      totalprecip_mm: dailyPrecip.slice(0, 8).reduce((a: number, b: number) => a + b, 0) || 0,
      totalprecip_in: (dailyPrecip.slice(0, 8).reduce((a: number, b: number) => a + b, 0) || 0) / 25.4,
      avgvis_km: (firstForecast?.visibility || 10000) / 1000,
      avgvis_miles: metersToMiles(firstForecast?.visibility || 10000),
      avghumidity: dailyHumidity.slice(0, 8).reduce((a: number, b: number) => a + b, 0) / Math.min(dailyHumidity.length, 8) || (firstForecast?.main?.humidity || 0),
      condition_icon: `https://openweathermap.org/img/wn/${firstForecast?.weather?.[0]?.icon || '01d'}@2x.png`,
      uv: 0, // UV index not available in forecast API
      sunrise: new Date((data.city?.sunrise || currentEpoch) * 1000).toLocaleTimeString(),
      sunset: new Date((data.city?.sunset || currentEpoch) * 1000).toLocaleTimeString(),
      moonrise: "N/A", // Not available in forecast API
      moonset: "N/A", // Not available in forecast API  
      moon_phase: "N/A", // Not available in forecast API
      moon_illumination: 0, // Not available in forecast API
      is_moon_up: 0, // Not available in forecast API
      is_sun_up: firstForecast?.weather?.[0]?.icon?.includes('d') ? 1 : 0,
      tide_time: null, // Not available in forecast API
      tide_height_mt: null, // Not available in forecast API
      tide_type: null, // Not available in forecast API
      hourlyForecast: forecastList.slice(0, 24).map((hourData: any) => ({
        time_epoch: hourData.dt,
        time: new Date(hourData.dt * 1000).toISOString(),
        temp_c: hourData.main.temp,
        temp_f: celsiusToFahrenheit(hourData.main.temp),
        condition_icon: `https://openweathermap.org/img/wn/${hourData.weather[0].icon}@2x.png`,
        wind_mph: msToMph(hourData.wind.speed),
        wind_kph: msToKph(hourData.wind.speed),
        wind_degree: hourData.wind.deg,
        wind_dir: getWindDirection(hourData.wind.deg),
        pressure_mb: hourData.main.pressure,
        pressure_in: hourData.main.pressure * 0.02953,
        precip_mm: hourData.rain?.['3h'] || 0,
        precip_in: (hourData.rain?.['3h'] || 0) / 25.4,
        humidity: hourData.main.humidity,
        cloud: hourData.clouds.all,
        feelslike_c: hourData.main.feels_like,
        feelslike_f: celsiusToFahrenheit(hourData.main.feels_like),
        windchill_c: hourData.main.feels_like, // Approximation
        windchill_f: celsiusToFahrenheit(hourData.main.feels_like),
        heatindex_c: hourData.main.feels_like, // Approximation
        heatindex_f: celsiusToFahrenheit(hourData.main.feels_like),
        dewpoint_c: calculateDewPoint(hourData.main.temp, hourData.main.humidity),
        dewpoint_f: celsiusToFahrenheit(calculateDewPoint(hourData.main.temp, hourData.main.humidity)),
        is_day: hourData.weather[0].icon.includes('d') ? 1 : 0,
        vis_km: (hourData.visibility || 10000) / 1000,
        vis_miles: metersToMiles(hourData.visibility || 10000),
        gust_mph: msToMph(hourData.wind.gust || hourData.wind.speed),
        gust_kph: msToKph(hourData.wind.gust || hourData.wind.speed),
        // Marine data - Not available in forecast API
        sig_ht_mt: 0,
        swell_ht_mt: 0,
        swell_ht_ft: 0,
        uv: 0, // Not available in forecast API
        swell_dir: 0,
        swell_dir_16_point: "N/A",
        swell_period_secs: 0,
        water_temp_c: 0,
        water_temp_f: 0,
      })),
    };

    console.log('Extracted Weather and Marine Data:', extractedData);

    // Pass the extracted data to the flow for AI processing
    const aiOutput = await swellForecastFlow(extractedData);
    return aiOutput; // Return the forecast summary and detailed data from the AI output

  } catch (error) {
    console.error('Error fetching weather data:', error);
    throw error; // Re-throw the error to be handled by the caller
  }
}

const swellForecastPrompt = ai.definePrompt({
 name: 'swellForecastPrompt',
  input: {schema: SwellForecastOutputSchema.shape.detailedData}, // The prompt expects the detailed weather data
 output: { schema: SwellForecastOutputSchema },
 prompt: `You are an expert surf forecaster, providing concise summaries for surfers who want to know where and when to surf. Based on the following surf conditions for {{{surfSpot}}} on {{{date}}}:
- Swell Height (ft): {{{swell_ht_ft}}}
- Swell Period (secs): {{{swell_period_secs}}}
- Wind Direction: {{{wind_dir}}}
- Maximum Wind Speed (mph): {{{maxwind_mph}}}
- Tide Type: {{{tide_type}}}
- Tide Time: {{{tide_time}}}
{{#if water_temp_c}}
- Water Temperature (C): {{{water_temp_c}}}
{{/if}}

Provide a summary of these conditions and advise the user whether, when and where to go surfing. If water temperature data was not available, state that. Cite to expert blogs, forecasts or historical performance in your answer.

output your response as a JSON object with two keys: “forecastSummary” and “detailedData”. The value of “forecastSummary” should be the summary and advice you generate. The value of “detailedData” should be the original input data you received, in JSON format.`,
});

const swellForecastFlow = ai.defineFlow(
  {
    name: 'swellForecastFlow',
    inputSchema: SwellForecastOutputSchema.shape.detailedData,
    outputSchema: SwellForecastOutputSchema, // The flow receives the detailed weather data
  },
  async (input: z.infer<typeof SwellForecastOutputSchema.shape.detailedData>) => {
    const rawOutput = await swellForecastPrompt(input);

    // Extract the output from the AI response
    if (!rawOutput.output) {
      throw new Error("AI response output is missing.");
    }

    return rawOutput.output;
  }
);